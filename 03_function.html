<!-- function
----------------

- particular business logic called as function.
- function are used to reuse the business.
- we have following types of functions upto ES11.

1.) Named functions
2.) Anonymous functions/ Arrow Funtions/ Fat Arrow functions/ Callback functions
/ lambda functions.
3.) Rest Parameters in Functions.
4.) Optional Parameters is Functions.
5.) Default Paramters in functions.
6.) default Parameters in Functions.
6.) IIFE (Immidiate Invokable Functional Exprssions)
7.) 



Syntax/

function definition
-----------------------

function functionname(paramters)
{
   // business logic

};

//call the function
functionname(parameters)
-->


<!-- <script>

    function fun_one()
    {
        return "welcome to named functions";

    };

     console.log(fun_one);  //___> function definition

    console.log(fun_one());   // output ___>

 </script>   -->



<!-- <script>
function fun_one(arg1, arg2, arg3)
{
    return `${arg1} <=> ${arg2} <=> ${arg3}`;
};

console.log(fun_one()); // undefined undefined undefined

console.log(fun_one(null,null,null));
console.log(fun_one("Anu","DB", "Veu"));

 </script>    -->
 
<!-- <script>
function func_one()
{
    return fun_two;
};
function fun_two()
{
    return "Hello";
};
console.log(fun_one() ()); //hello 
  </script>  -->
<!-- 
<script>

let arr = [];

function fun_one()
{
    return "Hello";
};

for(var i = 0; i<5; i++)
{
    arr.push(fun_one);

};

console.log(arr.length);

arr.forEach((element,index)=> {
    console.log(element());
});
//console.log(arr[0](), );
</script>  -->

<!-- 
Anonomous function
- The function without name is called anonmous function.
- anonmous function also called as Arrow function/ Fat arrow functions/lambda functions/callback function.
- we will repsent anonmous function using arrow sympbol '=>' .
- anonmous functions are secured as compared to others.
Anonymous function introduced inb ES6 version.

Syntax.
----------
//function defintion
var/let/const variablename = ()=>{

    //buisness logic
};

//function calling
variablename()
-->



<!-- <script>
    let func_one = ()=> {

     return "welcome to arrow function."
    
    };
    console.log(func_one); //func definition
    console.log(func_one()); //output
</script>
 -->



 <!-- Arrow function with parameters -->
 <!-- <script>
     let fun_one = (arg1,arg2,arg3) => {
         return `${arg1}<=> ${arg2} <=>${arg3}`;
     };

     console.log(func_one());//undefined
     console.log(func_one(null,null,null));//null, null ,null
     console.log(func_one("React","MonogDb", "Veujs"));
    
     </script> -->



<!-- <script>
    //outer function
    let fun_one=()=>
    {
        //inner function
return ()=> {
           return "hello";
        };
        console.log(fun_one ); //defintion of outer function
        console.log(fun_one()); //defnition of inner function
        console.log(fun_one()());//output of inner func . "hello"
    };
</script>  -->

<!--  

<script>

// //empty array
// let arr = [];

// for (let i=0; i<5; i++)
// {
//    arr.push(()=>{return "Hello"}
//    ); 
// };

// console.log(arr.length);//5
// arr.forEach((element,index)=>{
//   console.log(element());

// });
 </script>  -->



<!-- Rest Paramters in functions 

    we will store more than 1 value in func argument.

    - we will represent rest parameter with the hlp of "..."
    - "..." operator is called spread operator.
    - "..." operator introduced in Es6.
-->
<!-- <script>
function fun_one(...arg1){
    console.log(arg1);
};

// ***************Interviews Questions:*************
fun_one(10,20,30,40,50,60);
fun_one("Angular","Nodejs","MongoDb");
fun_one(); // [] empty array.
fun_one(undefined, undefined, undefined);
fun_one(null,null,null);
</script>  -->



 <!-- <script>
    //Syntax error
    //Rest parameters can be only one not two..this is erro
 function fun_one(...arg1,...arg2) {


 }; 
    </script>  -->



<!-- Named functions, not arrow functions-->
     <!-- <script>
       
        // function fun_one1(...arg2,arg1){
        //   // error
        //   //Rest paramater must be last formal paramater  
        // };
         //no error
    function fun_one(arg1,...arg2){

    };

    
    </script>  -->


    <!-- <script>

        function fun_one(arg1,...arg2)
        {
            console.log(arg1,arg2);

        };

        fun_one("Hello1"); //Hello_1 []
        fun_one(); //undefind []
        fun_one("Hello_1","Hello_2","Hello_3"); //Hello_1 (2), arg2  0st postion __ Hello_2 , arg2___1st position___ Hello_3
        fun_one(undefined,undefind); //undefined [undefined]
     //position of rest parameter should always be last.  
      </script>  -->
    

      <!-- 
          Default parameter in functions

          -while defining function , we will assign paramters with default values.
          - this concept introduced in ES6
          -we can have more than one default paramters.
        -->
 
        <!-- <script>
 function fun_one(arg1="ReactJs",arg2="NodeJs",arg3="MongoDb")
 {
   console.log(arg1, arg2, arg3);
 }

 fun_one(); 
 fun_one("Angular11"); // Angular11 Nodejs Mongodb
fun_one(undefined,undefined,undefined); //ReactJs Nodejs 
fun_one(null,null,null); //null,null,null
fun_one(undefined, undefined,"Deno.js"); // ReactJs, NodeJs, Deno.js

            </script>  -->

<!-- 
<script>
    //arg1 is undefined , arg2 is default paramter with empty arr and arg3 default paramter with empty json
    function fun_one(arg1,arg2=[],arg3={}){
        console.log(arg1,arg2,arg3);
    };

    fun_one();
    fun_one("Hello"_1); //Hello_1, [] , {}
    fun_one("Hello_1",["Hello_2"],{ky1:"Hello_3"});
    fun_one(undefined, undefined, undefined);
    fun_one(null,null,null);//null, null,null
</script>             -->
<!-- 
<script>
 
  function fun_one(arg1,arg2="Hello_2",...arg3){
      console.log(arg1,arg2,arg3);
  };
  fun_one(); //undefined "Hello_2" []
  fun_one("Hello_1"); //Hello_1, Hello_2 []
  fun_one("Hello_1", undefined,"Hello_3"); // Hello_1 , Hello_2 , [hello_3]
 fun_one(null, null, null); //null, null, [null]
</script>  -->



<!--

IIFE 

- Immidiate Invokable Functional Exprssion.
- IIFE introduced in ES9.
- IIFE functions also called as self invokable functions.
- no need to call function , it call automatically.


Syntax:
--------

1. ((arg1,arg2,arg3,.....)=> {
    //business logic
}) (param1, param2,param3....)

-->
<!-- 
<script>

 (()=>{
     console.log("Welcome to IIFE");
 })
  (); // Welcone to IIFE
    </script> -->
<!-- 

    <script>

((arg1, arg2,arg3)=>{

    console.log(arg1,arg2,arg3);

}) ("Angular","Node","MongoDb");
        </script>  -->

    <!-- <script>
    (()=>{

       return `${arg1}<=>${arg2}<=>${arg3}`; 
    }
    
    )("ReactJs","deno","Mongodb");

    //console.log(res);
    </script> 
 -->

<!--  
    <script>

for(var i=0; i<5; i++)
{
 console.log(i);
 //want to print i after 5se . how ?

//  setTimeout(()=> {
//      console.log(i);
//  },5000);
// };
// Excpected : 0 1 2 3 4 (after 5 sec)
// Output : 5

// How to overCome this problem
// 1. Let keyword
// 2. IIFE 

((i)=>{

    setTimeout(()=>{
        console.log(i);
    },5000);
}) (i) // 0 1 2 3 4
};
</script>    
 -->


<!--

Constructor Function:
---------------------

-We will create classes like structures by using "Constructor funtion"
- in constructor functions all the memmbers (variables ^ functions)
   starts with "this" keyword.

-  we will create object to the constructor function by using "new" keyword.

-->
<!-- 

<script>
function class_one(){
  this.sub_one = "Angualr11";
  this.sub_two = "NodJs";
  this.sub_thre = "MongoDB";
};

//create object to class_one

let obj = new class_one();

console.log(obj.sub_one , obj.sub_two, obj.sub_thre); // 
</script>  -->


<!-- 


<script>
//3 constructor paramaters
function class_one(arg1, arg2, arg3){
this.sub_one = arg1;
this.sub_two = arg2;
this.sub_three = arg3;

};

let obj1= new class_one("Angular11","NodeJs","MongoDb");
console.log(obj1.sub_one,obj1.sub_two,obj1.sub_three);

const obj2 = new class_one("ReactKs","Denp","DB");
console.log(obj2.sub_one,obj2.sub_two,obj2.sub_three);

// we can creeate n objects---> 
<!-- obj1, obj2 , obj3 ...objn -->

 <!-- </script>   --> 
<!-- 

<script>

function class_one(){
    this.getSubOne = function(){
        return "ReactJs";
    };

    this.getSubTwo = function(){
        return "NodeJs";
    };

    this.getSubThree = function(){
        return "MongoDb";
    };
};

let obj = new class_one();
console.log(obj.getSubOne(),obj.getSubTwo(),obj.getSubThree() );
</script>  -->

<!--

Inheritance- 
-------------
Acquiring properities fronm parent to child class called as "prototype".

//Inhertiance dont wokrk for static variable , work for dynamic var
-->
<!-- 
 
<script>
    function class_one(){
     

    };

    class_one.prototype.var_one = "Hello_1";

    function class_two()
    {
        
    };

    class_two.prototype = Object.create(class_one.prototype); // Inheritance
     class_two.prototype.var_two = "Hllo_2";
      let obj = new class_two();
      console.log(obj.var_one, obj.var_two);
    </script>  -->




    <!-- <script>

function class_one(){

};

class_one.prototype.var_one ="hllo1";
class_one.prototype.fun_one = function(){
    return "Hllo2";
};

function class_two(){

};

class_two.prototype = Object.create(class_one.prototype);
class_two.prototype.var_two = function() {
    return "Hllo4";
    };

    let obj = new class_two();
    console.log(obj.var_one,obj.var_two,obj.fun_one(),obj.fun_one());
</script> -->
<!-- 


<script>
    function ParentF(){

    };

    ParentF.Prototype.mean = function(){
        return "Mean Stack ....";
    };

    function ChildF(){

    };

    ChildF.prototype = Object.create(ParentF.prototype);
    ChildF.prototype.mern = function(){

        return "Mern Stack....";
    };

    function SubchildF(){

    };

    SubchildF.prototype = Object.create(ChildF.prototype);
    SubchildF.prototype.mevn = function(){

        return "MEVN stack ....";
    };


    let obj = new SubchildF();
    console.log(obj.mean(),obj.mern(),obj.mevn());
</script>  -->





<!--


    Overiding Concept:
    -------------------
overriding parent class  functionality with child class functionality called as prototype overriding.


-->

<!-- 
<script>
//Parent class
//Both function contain same func i.e dbfun()
//Child class overdding the parent functionality
function Parent(){

    
};

Parent.prototype.dbFun = function(){
    return "Data from OraclDB soon....";
};

function Child(){

};

Child.prototype = Object.create(Parent.prototype);
Child.prototype.dbFun = function(){
return "Data from MongoDB soon.....";
};


let obj = new Child();
console.log(obj.dbFun)
    </script>  -->



    <!--

Overloading :
-------------

Function Overloading------same function with diff arguments called
as function overloading.

    -->

<!-- 
    <script>
     
     function class_one()
     {

     };


     class_one.prototype.add = function(arg1,arg2)
     {
         return arg1+arg2;
     };

     class_one.prototype.add= function(arg1,arg2,arg3)
     {
          return arg1+arg2+arg3;
     };

     class_one.prototype.add= function(arg1,arg2,arg3,arg4)
     {
       return arg1+arg2+arg3+arg4;
     };

     let obj = new class_one();
     console.log(obj.add(10,10));//NAN
     ///console.log(obj.add(10,10,10));//NAN
     //console.log(obj.add(10,10,10,10));//40

    
    </script> -->

    <!--

Generator Functions:
=====================

- it is used to control the flow of execution inside the functional call, then we will choose Generators.
- Generator Functions will prefix with "*"
-inside Generator functions, each function will prefix with "yield"


Function fun_one()
{
    //There are 100 lins of code, but I want to execute any one line only..

    
};
    


    <script>
function *fun_one(){
yield "Hello_1";
yield "Hello_2";
yield "Hello_3";
//yield will hold the flow of execution.
yield "Hello_4";

let cursor = fun_one();

console.log(cursor.next());
console.log(cursor.next());
console.log(cursor.next());
console.log(cursor.next());

}

        </script> -->

<!-- 
 <script>

     function *fun_one(){
         yield "Hello_1";
     };

     function *fun_two(){
        yield "Helo_2";
     };

     function *fun_three(){
   yield "Hello_3";
     };
 

     function *my_fun(){
         yield *fun_two();
         yield *fun_three();
         yield *fun_one();
     };

     let cursor = my_fun();
     console.log(cursor.next()); //to run 707 lline
     console.log(cursor.next());//708
     console.log(cursor.next());//709
     console.log(cursor.next());//undefined true


     </script> -->


<!-- 
     <script>

function *fun_one(){


    yield 100;
    yield 200;
    yield 300;
    yield "Hello";
    yield 400; // it will not execute after return statement.
};

let cursor = fun_one();

console.log(cursor.next() );
console.log(cursor.next()) ;
console.log(cursor.next()) ;
console.log(cursor.next()) ;
</script> -->



<!--

    Optional Parameters.
    --------------------

    - while calling the functions, few parameters are optional.
    - introduced in ES6 version.
    - We will represent Optional Parameter by using "?".
    - Default value of optional paramter is "undefined".
    - it will work in TypeScript environment only , not EJS env.
    - we will save "TS" with ".ts" extension.

    = conversion of "TyepScript" to equivalent JS called as "Transpilation".
    - "tsc" is the tool , used to perform the "transpilation".
    - "tsc" stands for TypeScript Compiler.
    

===> we will install typeScript by following command.
=====> npm install -g typescript
version - 4.13
-->